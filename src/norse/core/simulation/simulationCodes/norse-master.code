{{ #simulation.code.importModules }}
# import norse
# import torch
# import numpy as np
{{ /simulation.code.importModules }}

{{ #simulation.code.createNodes }}
# Create stimulators
{{ #network.nodes.stimulators }}
{{ view.label }} = torch.ones({{ params.timesteps.value }},{{ size }}) * {{ params.amplitude.value }}
{{ /network.nodes.stimulators }}

# Connect nodes
{{ #network.connections.connectionsWithoutRecorders }}
l1 = torch.nn.Linear({{ source.size }}, {{ target.size }}, bias=False)
l1.weight.data.fill_(1) # all to all connectivity
{{ /network.connections.connectionsWithoutRecorders }}

# Create neurons
{{ #network.nodes.neurons }}
{{ view.label }} = norse.torch.{{ modelId }}({{ #hasSomeVisibleParams }}p=norse.torch.LIFParameters({{ #filteredParams }}
  {{ id }}=torch.tensor({{ code }}),{{ /filteredParams }})
{{ /hasSomeVisibleParams }}{{ #network.nodes.hasSomeAnalogRecorder }}
{{ #hasSomeVisibleParams }}  , {{ /hasSomeVisibleParams }}record_states=True{{ /network.nodes.hasSomeAnalogRecorder }})
{{ /network.nodes.neurons }}
{{ /simulation.code.createNodes }}

{{ #simulation.code.runSimulation }}
# Run simulation
output1, state1 = n1(l1(dc1))

{{ #network.nodes.hasSomeSpikeRecorder }}
# Get spike times
spikes = np.argwhere(output1.detach().numpy() == 1)
response = {
  "events": [ {
    "times": spikes[:,0],
    "senders": spikes[:,1]
  } ],
}
{{ /network.nodes.hasSomeSpikeRecorder }}

{{ #network.nodes.hasSomeAnalogRecorder }}
# Get voltage
vm = state1.v.detach().numpy()
t = np.arange(0,100)
id = np.arange(0,10)
ids, ts  = np.meshgrid(id,t)

response = {
  "events": [ {
    "times": ts.ravel(),
    "senders": ids.ravel(),
    "V_m": vm.ravel()
  } ],
}
{{ /network.nodes.hasSomeAnalogRecorder }}

{{ /simulation.code.runSimulation }}
